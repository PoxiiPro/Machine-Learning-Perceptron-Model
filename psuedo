def predict(weights, instance): 
    # weights needs to be a list of two-element tuples, where the first element is w_vector, and the second is c_labels
    # Initialize label to be an empty array
    # For each weight, append the product of the weight label times the sign of the dot product of the corresponding weight vector and the instance
    # If the sign of the sum of this label is 1, return 1
    # Else, return 0

def run(Xtrain_file, Ytrain_file, test_data_file, pred_file):
    train_data = np.loadtxt(Xtrain_file, delimiter=",", dtype=float)
    train_labels = np.loadtxt(Ytrain_file, dtype=float)

    # Correct the train labels by changing all the 0s to -1s
 
    # Initialize all parameters
    epochs = 1
    k = 0
    w_vector = np.zeros((len(train_data), len(train_data[0])))
    c_labels = np.zeros(len(train_labels))

    for t in range(epochs + 1): 
        for i in range(len(train_data)): 
            # Set prediction to be the np.sign of the dot product of the w vector and the train data (hint: use numpy two dimensional array notation [i, j]) 
            # Develop c_labels as shown in the homework file 

    perceptrons = np.array([[v_i, c_i] for v_i,c_i in zip(v,c)], dtype=object)

    test_data = np.loadtxt(test_data_file, delimiter=",")
    predictions = [predict(perceptrons, data) for data in test_data]